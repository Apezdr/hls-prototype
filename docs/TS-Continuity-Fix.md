# Transport Stream Continuity Counter Fix

## Problem

In Just-In-Time (JIT) transcoding, independent FFmpeg processes are spawned for each segment or batch of segments. Each process starts fresh with its own Transport Stream (TS) state, including Continuity Counters that always begin at 0. When these segments are played sequentially, media players encounter abrupt discontinuities in these counters (e.g., jumping from 10 back to 0 between segments), causing playback errors and seeking issues.

Common errors encountered:
```
ts error: libdvbpsi error (PSI decoder): TS discontinuity (received 0, expected 10) for PID 17
ts error: libdvbpsi error (PSI decoder): TS discontinuity (received 0, expected 8) for PID 0
```

## Solution

The solution involves post-processing TS segments to maintain continuity counters across independently generated segments. This is implemented using the `mux.js` library to parse, adjust, and rewrite TS packet headers.

### Key Components

1. **`utils/tsProcessor.js`**: A new utility module that provides:
   - In-memory state tracking for continuity counter values per PID for each stream variant
   - Functions to process segments and ensure proper continuity
   - Robust error handling for file locking and malformed packets

2. **Modified `segmentManager.js`**: Integration points that ensure:
   - All segments are processed before being served to clients
   - Processing happens automatically after FFmpeg generates segments
   - Both video and audio segments are handled consistently
   - When file locks prevent direct modification, alternative processed copies are used

### Implementation Details

#### State Management

- A memory-based store tracks the final continuity counter value for each PID in each segment.
- The state is keyed by `videoId_variantLabel` and stores a mapping of PIDs to counter values.
- This ensures continuity is maintained properly for each unique stream variant.

#### TS Processing Workflow

1. When a segment is generated by FFmpeg, the `processTsSegment` function is called.
2. For the first segment in a sequence (segment 0), the function simply stores its final CC values.
3. For subsequent segments:
   - The previous segment's final CC values are retrieved
   - The new segment's packets are parsed
   - For each PID, the CC values are adjusted to continue from the previous segment's values
   - The modified segment is written back to disk atomically
   - If the file is locked (being written or read), a separate processed copy is created

#### Integration Points

The fix is integrated at multiple key points:

1. **On-Demand Processing**: When existing segments are requested, they are processed (if not already) before being served. If a processed version (`processed_xxx.ts`) exists, it is served instead.

2. **Post-FFmpeg Processing**: When FFmpeg completes generating new segments, they are immediately processed before being marked as complete and made available.

3. **File Locking Handling**: The system detects when segment files are locked (being written by FFmpeg or read by a player) and creates alternative processed files instead of modifying the originals.

## Benefits

- **Seamless Playback**: Media players now experience proper continuity between segments, eliminating errors.
- **Improved Seeking**: The consistent TS state allows for reliable seeking throughout the content.
- **Compatibility**: Works with existing libraries and players without requiring modifications to them.
- **Minimal Overhead**: The processing is efficient and has minimal impact on segment serving time.
- **Fault Tolerance**: Robust error handling ensures playback continues even if processing fails.

## Technical Implementation

The solution uses `mux.js`, a JavaScript library for video container manipulation, to:

1. Parse TS packet structures
2. Extract continuity counters from packet headers
3. Modify these counters based on the previous segment's state
4. Reconstruct the TS packets with adjusted headers

All packet types are handled correctly, including PAT (Program Association Table), PMT (Program Map Table), and elementary stream packets, each with their specific requirements for continuity counter handling.

This approach allows maintaining proper Transport Stream state across independently generated segments without requiring modifications to FFmpeg itself or its invocation.
